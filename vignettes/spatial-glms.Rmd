---
title: "Spatial GLMs with glmmfields"
author: "Sean C. Anderson and Eric J. Ward"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spatial GLMs with glmmfields}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
  
Here we will use the `glmmfields` package to fit a spatial GLM. While the `glmmfields` package was designed to fit spatiotemporal GLMs with the possibility of extreme events, it can also be used to fit regular spatial GLMs without a time element and without extreme events. Currently it can fit Gaussian (link = identity), Gamma (link = log), poisson (link = log), negative binomial (link = log), and binomial (link = logit). Although outside the formal GLM family, the package can also fit lognormal (link = log).
  
```{r set-knitr-options, cache=FALSE, echo=FALSE}
library("knitr")
opts_chunk$set(message=FALSE, fig.width = 5)
```

Let's load the necessary packages:

```{r}
library(glmmfields)
library(ggplot2)
library(dplyr)
```

Set up parallel processing:

```{r, echo=TRUE}
if (interactive()) options(mc.cores = parallel::detectCores())
```

Let's simulate some data to fit our model to. We will use the built-in function `sim_glmmfields()`, but normally you would start with your own data. We will simulate 300 data points, some temperature data, an underlying random field spatial pattern, and add some observation error. 

In this example we will fit a Gamma GLM with a log link.

The underlying intercept is 0.5 and the slope between temperature and our observed variable (say biomass or density of something) is 0.2.

```{r simulate-data}
set.seed(123)
N <- 100 # number of data points
temperature <- rnorm(N, 0, 1) # simulated temperature data
X <- cbind(1, temperature) # our design matrix
s <- sim_glmmfields(n_draws = 1, gp_rho = 2, n_data_points = N,
  gp_eta = 0.3, sd_obs = 0.2, n_knots = 12, obs_error = "gamma",
  covariance = "squared-exponential", X = X,
  B = c(0.5, 0.2)) # B represents our intercept and slope
d <- s$dat
d$temperature <- temperature
ggplot(s$dat, aes(lon, lat, colour = y)) +
  viridis::scale_colour_viridis() +
  geom_point(size = 3)
```

If we fit a regular GLM we can see that there is spatial autocorrelation in the residuals:

```{r}
m_glm <- glm(y ~ temperature, data = d, family = Gamma(link = "log"))
m_glm
confint(m_glm)
d$m_glm_residuals <- residuals(m_glm)
ggplot(d, aes(lon, lat, colour = m_glm_residuals)) + 
  scale_color_gradient2() +
  geom_point(size = 3)
```

Let's instead fit a spatial GLM with random fields. (Note that we are only using 2 chains and 600 iterations here so the vignette builds quickly. For final inference, you should likely use 4 or more chains and likely more iterations.)

```{r, results='hide'}
m_spatial <- glmmfields(y ~ temperature, data = d, family = Gamma(link = "log"), 
  lat = "lat", lon = "lon", nknots = 12, iter = 600, chains = 2)
```

```{r}
m_spatial
```

We can see that the 95% credible intervals are considerably wider on the intercept term and narrower on the slope coefficient in the spatial GLM vs. the model that ignored the spatial autocorrelation.

Let's look at the residuals in space this time:

```{r}
plot(m_spatial, type = "spatial-residual", link = TRUE) +
  geom_point(size = 3)
```

That looks better. 

And the predictions from our model itself:

```{r}
plot(m_spatial, type = "prediction", link = FALSE) +
  viridis::scale_colour_viridis() +
  geom_point(size = 3)
```

Compare that to our data at the top. Note that the original data also includes observation error with a CV of 0.2.
